# RID Qualifier Tests

This directory contains a series of tests for qualifying Network Remote ID compliance. It will contain four things:

1. **Flight track dataset generator** (`flight_data_generator.py`): An API to generate multiple flight paths and patterns within a specified bounding box. You can specify a bounding box in any part of the world the generator will create a grid for flights for the bounds provided. In addition, circular flight paths will be generated within that grid. The output of this API are flight data file artifacts in GeoJSON [FeatureCollection](https://tools.ietf.org/html/rfc7946#section-3.3) format. In addition to the flight tracks, query bounding boxes are also generated as a GeoJSON FeatureCollection format. Finally the flight tracks are converted to a `RIDAircraftState` data: by adding metadata and timestamps to the points. The conversion of flight track points to RIDAircraftState can be considered as a simplified simulation. All the files, once generated are stored in the `test_definitions` directory.

2. **Aircraft state replayer** (`aircraft_state_replayer.py`): Using the flight data generated by the previous tool, we simulate flights and "fly" them by emitting aircraft states to be fed to the Remote ID Service Provider test harnesses. Specific details and metadata about the flights are included when submitting to the SP test harnesses via the injection API.

3. **Test executor**: (`test_executor.py`) The test executor is  the main routine of `rid_qualifier`: it instructs the `aircraft_state_replayer` to send test data into each SP's injection harness, and then asks the `display_data_evaluator` to query the RID system for expected data and evaluate the query results against expectations to produce qualification results.

4. **Display Data Evaluator**: Once test aircraft state data is sent to each Remote ID Service Provider's injection test harness to be injected into their systems, the state of the RID system must be queried and then the results of those queries compared against expected results. This module performs the latter tasks of querying the RID system through each specified Remote ID Display Provider's observation test harness, and comparing those query results against expectations. [Flight Blender](https://github.com/openskies-sh/flight-blender) is an open-source Remote ID Display Provider that will implement an observation test harness, and therefore can be used to test compliance.

# Create Flight Record from KML
[create_flight_record_from_kml.py](rid/generators/flight_state_from_kml.py) accepts a KML file with one/many flights defined in the KML folders and produce a set of JSON files for each such flight, snapshoting the aircraft's state every sample_rate. Every flight needs exactly one path (LineString) and this is the path the aircraft takes over the ground. Speed and altitude of the flight  are defined by the polygons surrounding the path.

Following are the specifications for input KML:

- **Flight path**: KML must contain one folder for each flight path. Folder name should be prefixed with "flight: " and the flight ID of the flight, e.g. "flight: fly_north". Every flight needs exactly one path (LineString) and this is the path the aircraft should take over the ground. Rest of the characteristics of the flight are defined in the folder's description, including the sample_rate (in Hertz).

- **Speed zones**: Speed zones for a flight should be defined as polygons nested in the flight folder. Each speed polygon must be prefixed with "speed: " and include m/s in parenthesis. For example: "speed: Mission (2.5)".

- **Altitude zones**: Like speed, the polygon names prefixed with "alt: " are considered Altitude polygons for a flight path. Altitude of each point in the flight path is interpolated based on the distance of the point from the nearby altitude polygons.

- **Speed and Altitude interpolation**: Speed and Altitude of each point is interpolated by adding weight of surrounding zones where weigh of each zone is 1/distance of the zone from the point. For example: If zone 1 was at 10m altitude 10m away, zone 2 was at 20m altitude 50m away, and zone 3 was at 30m altitude 100m away, the weights would be 1/10 for zone 1, 1/50 for zone 2, and 1/100 for zone 3.  So, the aircraft altitude would be (10/10 + 20/50 + 30/100) / (1/10 + 1/50 + 1/100) = 13.1m.

- Flight states for a KML file can be generated by running [run_flight_state_locally.sh](run_flight_state_locally.sh). run_flight_state_locally.sh expects absolute path to the input KML file and output folder as parameters.
Example: `./run_flight_state_locally.sh <kml-file> <local-output-folder>`
`-d` flag can be passed to generate output state coordinates for each flight path. 


## Running locally

This tool can be run locally on your system via the [run_locally.sh](run_locally.sh) script. Please review that file to see the different options that can be configured before running instance locally. NB: A remote ID system to test must be available and configured before `run_locally.sh` is executed. A full mock RID system can be brought up locally using the [mock](mock/README.md)
